/**
 * This tests a feedback loop with physical actions and
 * centralized coordination.
 * 
 * @author Edward A. Lee
 */

target Python {
    coordination: centralized,
    timeout: 5 sec
}
preamble {=
    import time
    import threading

    # Thread to trigger an action once every second.
    def ping(actionref):
        cnt = 0
        while cnt < 5:
            print("Scheduling action.")
            actionref.schedule(0)
            time.sleep(1)
            cnt += 1
=}

reactor Looper(incr(1), delay(0 msec)) {
    input in_;
    input in2;
    output out;
    output out2;
    physical action a(delay);
    state count(0);
    timer t(0, 1 sec);
    reaction(startup) -> a {=
        # Start the thread that listens for Enter or Return.
        print("Starting thread.")
        x = threading.Thread(target=ping, args=(a, ))
        x.start()        
    =}
    reaction(a) -> out, out2 {=
        if self.count%2 == 0:
        	out.set(self.count)
        else:
            out2.set(self.count)
        self.count += self.incr
    =}
    reaction(in_) {=
        print(
            f"Received {in_.value} at logical time ({lf.time.logical_elapsed()}, {lf.tag().microstep})."
        )
    =}
    reaction(in2) {=
        print(
            f"Received {in2.value} on in2 at logical time ({lf.time.logical_elapsed()}, {lf.tag().microstep})."
        )
    =}
    reaction(t) {=
        print(
            f"Timer triggered at logical time ({lf.time.logical_elapsed()}, {lf.tag().microstep})."
        )
    =}
    reaction(shutdown) {=
        print("******* Shutdown invoked.")
        # Stop the thread that is scheduling actions.
        if self.count != (5 * self.incr):
            sys.stderr.write("ERROR: Failed to receive all five expected inputs.")
            exit(1)
    =}
}
federated reactor (delay(0)) {
    left = new Looper();
    right = new Looper(incr = -1);
    left.out -> right.in_;
    right.out -> left.in_;
    right.out2 -> left.in2;
    left.out2 -> right.in2;
}
